<meta charset="utf-8">
<div class="entry-content">
 <p>
  A common approach to volume render big datasets is splitting the data into blocks and rendering each block in a separate pass.  A final image is then constructed by orderly compositing (back-to-front) the images rendered with each block (a process known as bricking).  A variety of artifacts can arise when using bricking due to discontinuous data sampling, gradient computation at the edges, etc.  One common artifact is that block seams become apparent thus lowering the final composite image quality.
 </p>
 <div class="wp-caption alignnone" id="attachment_16545" style="width: 838px">
  <img alt="seams_0_current_arrow" class="wp-image-16545 size-full" height="649" sizes="(max-width: 828px) 100vw, 828px" src="https://blog.kitware.com/wp-content/uploads/2016/11/seams_0_current_arrow.png" srcset="https://blog.kitware.com/wp-content/uploads/2016/11/seams_0_current_arrow.png 828w, https://blog.kitware.com/wp-content/uploads/2016/11/seams_0_current_arrow-300x235.png 300w, https://blog.kitware.com/wp-content/uploads/2016/11/seams_0_current_arrow-768x602.png 768w, https://blog.kitware.com/wp-content/uploads/2016/11/seams_0_current_arrow-220x172.png 220w, https://blog.kitware.com/wp-content/uploads/2016/11/seams_0_current_arrow-250x196.png 250w, https://blog.kitware.com/wp-content/uploads/2016/11/seams_0_current_arrow-355x278.png 355w, https://blog.kitware.com/wp-content/uploads/2016/11/seams_0_current_arrow-730x572.png 730w, https://blog.kitware.com/wp-content/uploads/2016/11/seams_0_current_arrow-90x71.png 90w" width="828"/>
  <p class="wp-caption-text">
   A wavelet volume rendered as 4 blocks with the GPU Mapper. Seam artifacts due to discontinuous sampling are clearly seen near the center planes at the edges of the blocks (black arrows).
  </p>
 </div>
 <p>
  Parallel volume rendering in ParaView works in a similar fashion, different data blocks are rendered in separate processes and are then orderly composited together into a final image. Former versions of ParaView would show visible seams when rendering volumes in parallel.  Certain improvements in the GPUMapper will alleviate these sampling artifacts as of ParaView 5.2 (OpenGL2).  Specifically,
 </p>
 <p>
  <strong>
   a.  Sampling Distance:
  </strong>
  First, the ray sampling distance used by both the GPU and CPU mappers in ParaView was equalized.  vtkFixedPointVolumeRayCastMapper (CPU) has an internal mode (LockSampleDistanceToInputSpacing) which would further decrease the sampling distance passed by vtkSmartVolumeMapper, making artifacts more evident in the GPU mapper.  To
  <br/>
  correct this, LockSampleDistanceToInputSpacing was enabled in the GPU mapper.
 </p>
 <div class="wp-caption alignnone" id="attachment_16546" style="width: 838px">
  <img alt="seams_1_equalizedSpacing_arrow" class="wp-image-16546 size-full" height="649" sizes="(max-width: 828px) 100vw, 828px" src="https://blog.kitware.com/wp-content/uploads/2016/11/seams_1_equalizedSpacing_arrow.png" srcset="https://blog.kitware.com/wp-content/uploads/2016/11/seams_1_equalizedSpacing_arrow.png 828w, https://blog.kitware.com/wp-content/uploads/2016/11/seams_1_equalizedSpacing_arrow-300x235.png 300w, https://blog.kitware.com/wp-content/uploads/2016/11/seams_1_equalizedSpacing_arrow-768x602.png 768w, https://blog.kitware.com/wp-content/uploads/2016/11/seams_1_equalizedSpacing_arrow-220x172.png 220w, https://blog.kitware.com/wp-content/uploads/2016/11/seams_1_equalizedSpacing_arrow-250x196.png 250w, https://blog.kitware.com/wp-content/uploads/2016/11/seams_1_equalizedSpacing_arrow-355x278.png 355w, https://blog.kitware.com/wp-content/uploads/2016/11/seams_1_equalizedSpacing_arrow-730x572.png 730w, https://blog.kitware.com/wp-content/uploads/2016/11/seams_1_equalizedSpacing_arrow-90x71.png 90w" width="828"/>
  <p class="wp-caption-text">
   After correcting for (a.). Seams faded out, as expected with a higher sampling rate, but are still visible at the block-edge planes.
  </p>
 </div>
 <p>
  <strong>
   b.  Cell-texture-coordinates to Point-texture-coordinates:
  </strong>
  VTK defines its data set abstraction as points or cells. Cell data maps directly to OpenGL texture-cells however, point data does not given that VTK defines its points at the cell corners.  In order to adjust point data to the center of the OpenGL texture cells a transformation with a scaling diagonal and a translation vector needs to be applied.  Although the ray entry and texture limits were being adjusted, the ray step was not scaled accordingly,  this would introduce a slight source of error in point data sets (as in the case of the wavelet) which would maintain the seams noticeable even with a reduced sample distance.
 </p>
 <div class="wp-caption aligncenter" id="attachment_16505" style="width: 838px">
  <img alt="seams_2_cellToPoint_stepAdjusted" class="wp-image-16505 size-full" height="649" sizes="(max-width: 828px) 100vw, 828px" src="https://blog.kitware.com/wp-content/uploads/2016/11/seams_2_cellToPoint_stepAdjusted.png" srcset="https://blog.kitware.com/wp-content/uploads/2016/11/seams_2_cellToPoint_stepAdjusted.png 828w, https://blog.kitware.com/wp-content/uploads/2016/11/seams_2_cellToPoint_stepAdjusted-300x235.png 300w, https://blog.kitware.com/wp-content/uploads/2016/11/seams_2_cellToPoint_stepAdjusted-768x602.png 768w, https://blog.kitware.com/wp-content/uploads/2016/11/seams_2_cellToPoint_stepAdjusted-220x172.png 220w, https://blog.kitware.com/wp-content/uploads/2016/11/seams_2_cellToPoint_stepAdjusted-250x196.png 250w, https://blog.kitware.com/wp-content/uploads/2016/11/seams_2_cellToPoint_stepAdjusted-355x278.png 355w, https://blog.kitware.com/wp-content/uploads/2016/11/seams_2_cellToPoint_stepAdjusted-730x572.png 730w, https://blog.kitware.com/wp-content/uploads/2016/11/seams_2_cellToPoint_stepAdjusted-90x71.png 90w" width="828"/>
  <p class="wp-caption-text">
   After correcting for (b.). No sampling seams are visible.
  </p>
 </div>
 <p>
  <strong>
   Next Steps
  </strong>
 </p>
 <p>
  During interaction-time the sampling distance is increased which causes the sampling seams to become visible again.  It is possible to further correct the visibility of this artifact during interaction-time by offsetting the entry point in each brick to be a multiple along the entire ray (entry would be computed from the eye pose to make sure it is a multiple for each different brick). Additional work is needed to address the gradient computation at the edges in order to correct other artifacts present when shading is on.
 </p>
</div>

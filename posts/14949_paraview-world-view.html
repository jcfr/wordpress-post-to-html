<meta charset="utf-8">
<div class="entry-content">
 <p>
  This marks the beginning of series of blog posts that I intend to write (and can hopefully rope in others to write too) to give a new developer for ParaView, ParaView plugin, or a ParaView-based application  some overview on how things come together. To keep things manageable both for the reader and the writer, I intend to keep each post small and focused. This is surely an experiment and experiments are bound to go terribly wrong, so please feel free to give your feedback either in the comments section or on the
  <a href="http://www.paraview.org/mailing-lists/">
   mailing list
  </a>
  so we can continue to revise and learn from our mistakes as (and if) we continue with this.
 </p>
 <h1>
  The ideal reader
 </h1>
 <p>
  Before chugging along, let’s identify the target reader:
 </p>
 <ol>
  <li>
   You are well versed with using ParaView.
  </li>
  <li>
   You are familiar with VTK. You need not know all the crazy details of the pipeline just yet, but knowing what VTK data model is, VTK algorithms are, how pipelines are put together is assumed. ParaView is VTK. For an uninitiated observer, ParaView is not much more than a UI for VTK (clearly that’s too simplistic a view, but we all start somewhere).
  </li>
  <li>
   You are able to build ParaView from source.
  </li>
  <li>
   You are familiar with navigating the code, potentially using the online
   <a href="http://www.paraview.org/ParaView/Doc/Nightly/www/cxx-doc/index.html">
    Doxygen documentation
   </a>
   but ideally just opening your favorite editor (which is highly unlikely to be anything other than
   <a href="http://www.vim.org/">
    VIM
   </a>
   ) and looking at the source code.
  </li>
 </ol>
 <p>
  The objective here is not to document all the API but to give the reader some bearing as he or she dives into the code to hack it.
 </p>
 <h1>
  ParaView world view
 </h1>
 <p>
  If there is one thing that I always keep in mind when I am writing any code for ParaView, that would be the various modes in which ParaView can be used. Most users simply run ParaView using
  <strong>
   paraview
  </strong>
  executable. Seasoned users are aware that there are several other executables viz.
  <strong>
   pvserver
  </strong>
  ,
  <strong>
   pvdataserver
  </strong>
  ,
  <strong>
   pvrenderserver, pvpython
  </strong>
  , and
  <strong>
   pvbatch.
  </strong>
  <strong>
   paraview
  </strong>
  can be used by itself, or together with single
  <strong>
   pvserver
  </strong>
  , or a MPI group of several
  <strong>
   pvserver
  </strong>
  s, or together with
  <strong>
   pvdataserver + pvrenderserver
  </strong>
  or MPI groups of the same. To make it possible to support all these configurations without losing our hair (well, most of it anyways), it helps to think of ParaView as made up of 3 logical components:
  <strong>
   DataServer
  </strong>
  ,
  <strong>
   RenderServer
  </strong>
  , and
  <strong>
   Client
  </strong>
  . In any configuration, a process may act as one or more of these components.
 </p>
 <ul>
  <li>
   <strong>
    DataServer
   </strong>
   – This is component that does all the data processing. Thus all files that you open are opened here. All VTK readers, and filters that you apply to process your data are created here. All the data that is generated by various sources and filters lives here.
   <strong>
    DataServer
   </strong>
   is MPI-capable i.e. it can be running on a group of MPI ranks thus all the data that you’re reading and processing may be partitioned among multiple ranks.
  </li>
  <li>
   <strong>
    RenderServer
   </strong>
   – This does the rendering. Thinking in VTK terms, the mappers, actors, renderers, render windows etc. are here.
  </li>
  <li>
   <strong>
    Client
   </strong>
   – This is UI or scripting interface (Python) to control the data processing and rendering.
  </li>
 </ul>
 <p>
  The data gets processed on the
  <strong>
   DataServer
  </strong>
  and gets converted into
  <em>
   renderable artifacts
  </em>
  . These are then
  <em>
   shipped
  </em>
  to the
  <strong>
   RenderServer
  </strong>
  where the rendering happens. And all this is orchestrated by the
  <strong>
   Client.
  </strong>
 </p>
 <p>
  When you run
  <strong>
   paraview
  </strong>
  and are connected to the
  <em>
   builtin
  </em>
  server, all the 3 components are in the same process space and yet it’s a good habit to pretend they aren’t. The underpinnings may use shortcuts when doing data transfers, for example when
  <em>
   shipping
  </em>
  the renderable artifacts to the
  <strong>
   RenderServer
  </strong>
  from the
  <strong>
   DataServer,
  </strong>
  but unless you’re dealing explicitly with code that does that, you can just ignore that.
 </p>
 <p>
  In the next post, I will introduce the
  <strong>
   ServerManager
  </strong>
  — the backbone of ParaView infrastructure. This is the thing that makes it possible for the
  <strong>
   Client
  </strong>
  to do all the orchestration of the analysis and visualization pipelines irrespective of whether the server components are local or remote.
 </p>
 <p>
 </p>
</div>
